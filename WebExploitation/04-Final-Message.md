# The Final Message (750 Points)

**Category:** Web Exploitation  
**Points:** 750  
**Difficulty:** Expert  
**Theme:** Peer Ali Khan - The First Martyr of 1857

**Challenge Website:** https://rahipatel1285.github.io/pfswt1/

---

## Challenge Overview

Shaheed Peer Ali Khan's final message was split across multiple security vectors. Players must gather flag fragments from three different techniques:

1. **Canvas Steganography** - Hidden in image pixel data
2. **Timing Analysis** - Revealed through precise timing patterns
3. **Web Worker Communication** - Extracted from isolated worker context

---

## Prerequisites

Must complete Challenges 1, 2, and 3 first.

---

## Solution

### Vector 1: Canvas Steganography

#### Step 1: Find the Hidden Canvas

```javascript
// The canvas is hidden in the gallery section
const canvas = document.getElementById('hidden-gallery-canvas');
canvas.style.display = 'block';
```

#### Step 2: Extract LSB Data

Data is hidden in the Least Significant Bit (LSB) of the red channel:

```javascript
function extractFromCanvas(canvasId) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Extract LSB from red channel (every 4th byte, starting at 0)
    let binary = '';
    for (let i = 0; i < 1000; i++) {
        binary += (data[i * 4] & 1).toString();
    }
    
    // Convert binary to text
    const chars = binary.match(/.{8}/g);
    const text = chars.map(b => String.fromCharCode(parseInt(b, 2))).join('');
    
    // Remove null bytes
    return text.replace(/\0+$/, '');
}

// Using the built-in function
const canvasPart = Challenges.canvas.extract('hidden-gallery-canvas');
// Returns: "RjFuNGxfTTNzczRnMw==" (base64)

const decodedCanvas = atob(canvasPart);
// Returns: "F1n4l_M3ss4g3"
```

**Canvas Fragment:** `F1n4l_M3ss4g3`

---

### Vector 2: Timing Analysis

#### Step 1: Understand the Timing Challenge

The candle element has a hidden timing-based unlock. Clicks at specific intervals reveal data:

```javascript
// Expected pattern: 100ms, 200ms, 300ms, 400ms, 500ms intervals
const pattern = [100, 200, 300, 400, 500];
```

#### Step 2: Execute the Timing Pattern

```javascript
async function executeTimingPattern() {
    const candle = document.querySelector('.virtual-candle');
    const pattern = [100, 200, 300, 400, 500];
    
    // Reset timing tracker
    Challenges.timing.reset();
    
    // Execute pattern
    for (let i = 0; i <= pattern.length; i++) {
        // Record timestamp
        Challenges.timing.record(Date.now());
        
        // Simulate click
        candle.click();
        
        // Wait for next interval
        if (i < pattern.length) {
            await new Promise(r => setTimeout(r, pattern[i]));
        }
    }
    
    // Verify pattern and get fragment
    return Challenges.timing.verify();
}

const timingPart = await executeTimingPattern();
// Returns: "Sh4h33d_P33r"
```

**Timing Fragment:** `Sh4h33d_P33r`

---

### Vector 3: Web Worker Communication

#### Step 1: Discover the Hidden Worker

```javascript
// The worker is registered but dormant
const worker = Challenges.worker.get();
```

#### Step 2: Send Correct Authentication

```javascript
// The worker expects a specific handshake
async function extractFromWorker() {
    const worker = Challenges.worker.get();
    
    // Handshake message
    worker.postMessage({
        type: 'AUTH',
        token: 'peer_ali_1857',
        timestamp: Date.now()
    });
    
    return new Promise((resolve) => {
        worker.onmessage = (e) => {
            if (e.data.type === 'FLAG_FRAGMENT') {
                resolve(e.data.fragment);
            }
        };
    });
}

const workerPart = await extractFromWorker();
// Returns: "_4l1_Z1nd4b4d!"
```

**Worker Fragment:** `_4l1_Z1nd4b4d!`

---

### Combine All Fragments

```javascript
const canvasFragment = "F1n4l_M3ss4g3";
const timingFragment = "Sh4h33d_P33r";
const workerFragment = "_4l1_Z1nd4b4d!";

// Assembly order: Timing + Canvas + Worker
// Based on hints in each fragment's metadata
const flag = `pfswt{${timingFragment}_${canvasFragment}${workerFragment}}`;
// Or use the verification function
const result = await Challenges.verify.flag4(
    canvasFragment, 
    timingFragment, 
    workerFragment
);
```

---

## Complete Solution Script

```javascript
async function solveChallenge4() {
    console.log('Starting Challenge 4 solution...');
    
    // Vector 1: Canvas
    const canvasFragment = atob(
        Challenges.canvas.extract('hidden-gallery-canvas')
    );
    console.log('Canvas fragment:', canvasFragment);
    
    // Vector 2: Timing
    Challenges.timing.reset();
    const pattern = [100, 200, 300, 400, 500];
    const candle = document.querySelector('.virtual-candle');
    
    for (let i = 0; i <= pattern.length; i++) {
        Challenges.timing.record(Date.now());
        candle?.click();
        if (i < pattern.length) {
            await new Promise(r => setTimeout(r, pattern[i]));
        }
    }
    const timingFragment = await Challenges.timing.verify();
    console.log('Timing fragment:', timingFragment);
    
    // Vector 3: Worker
    const worker = Challenges.worker.get();
    const workerFragment = await new Promise((resolve) => {
        worker.postMessage({
            type: 'AUTH',
            token: 'peer_ali_1857',
            timestamp: Date.now()
        });
        worker.onmessage = (e) => {
            if (e.data.type === 'FLAG_FRAGMENT') {
                resolve(e.data.fragment);
            }
        };
    });
    console.log('Worker fragment:', workerFragment);
    
    // Combine and verify
    const result = await Challenges.verify.flag4(
        canvasFragment, 
        timingFragment, 
        workerFragment
    );
    console.log('Final flag:', result.flag);
    
    return result;
}

solveChallenge4();
```

---

## Flag

```
pfswt{F1n4l_M3ss4g3_Sh4h33d_P33r_4l1_Z1nd4b4d!}
```

---

## Flag Breakdown

| Part | Meaning |
|------|---------|
| `F1n4l_M3ss4g3` | Final Message - his last words |
| `Sh4h33d` | Shaheed - Martyr |
| `P33r_4l1` | Peer Ali - his name |
| `Z1nd4b4d!` | Zindabad - Long Live! |

---

## Technical Details

### Canvas Steganography (LSB)
The Least Significant Bit technique hides data by modifying the least important bit of each color channel. Changes are imperceptible to the human eye but can encode binary data.

### Timing-Based Challenges
By measuring precise intervals between user actions, websites can create timing-based puzzles. This requires:
- High-precision timing (performance.now())
- Tolerance for human error (~50ms)

### Web Workers
Web Workers run in isolated contexts, separate from the main thread. They communicate via postMessage(), creating a secure channel for sensitive operations.

---

## Anti-Debug Measures

This challenge includes several anti-debugging measures:
- DevTools detection (returns fake flags if detected)
- Rate limiting (50 attempts max)
- Timing randomization (500-1500ms delay)
- Fingerprint verification

---

## Tools Used

- Browser DevTools (carefully!)
- JavaScript console
- Understanding of canvas API
- Timing analysis
- Web Worker API
